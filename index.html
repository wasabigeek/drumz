<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script type="text/javascript" src="/js/bufferLoader.js"></script>
  <script type="text/javascript" src="https://unpkg.com/vexflow@3.0.9/releases/vexflow-min.js"></script>
</head>
<body>
  <label for="sticking">
    Sticking:
    <input id="sticking" value="RLKRLKRLKRLKRLRL" maxlength="16" minlength="16">
  </label>
  <button id="change_sticking">Change</button>
  <br /><br /><br />
  <div id="score"></div>
  <label for="tempo">
    Tempo:
    <input id="tempo" value="80" type="number">
  </label>
  <button id="play">Play</button>
  <script type="text/javascript">
    window.onload = init;
    var context;
    var drumkit;
    var VF = Vex.Flow;
    var vf = new VF.Factory({
      renderer: {
        elementId: "score",
        backend: VF.Renderer.Backends.SVG,
        width: 450,
        height: 140,
      },
    });

    function Instrument(options) {
      this.verticalPosition = options.verticalPosition;
      this.sound = options.sound;
    }

    function Note(options) {
      this.instrument = options.instrument;

      this.verticalPosition = this.instrument.verticalPosition;
      // this has to be lazily retrieved now because the AudioContext needs to load
      this.getSound = this.instrument.sound;
    }
    DURATION_SIXTEENTH = 'sixteenth';
    DURATION_EIGHTH = 'eighth';
    DURATION_QUARTER = 'quarter';
    function NoteGroup(notes, duration) {
      this.notes = notes;
      this.duration = duration;

    }

    function toNotation(noteGroup) {
      var keys = noteGroup.notes.map(function(note) { return note.verticalPosition });

      var vfDuration;
      switch (noteGroup.duration) {
        case DURATION_EIGHTH:
          vfDuration = '8';
          break;
        case DURATION_SIXTEENTH:
          vfDuration = '16';
          break;
        default:
          break;
      }

      return {
        keys: keys,
        duration: vfDuration
      }
    }

    function createMeasure(setup) {
      var stave = vf.Stave().addClef('percussion');

      setup(vf);

      vf.Formatter()
        .joinVoices(vf.getVoices())
        .formatToStave(vf.getVoices(), stave);

      vf.draw();
    }

    function generateNotation(score) {
      var context = vf.getContext()
      context.clear();

      createMeasure(function(vf) {
        var voice0 = vf.Voice().addTickables(
          score.map(function(noteGroup) {
            return vf.StaveNote(toNotation(noteGroup));
          })
        );
        vf.Beam({ notes: voice0.getTickables() });
      });
    }

    function init() {
      // Fix up prefixing
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext();

      drumkit = new DrumKit(context);
      var snareInstrument = new Instrument({ verticalPosition: 'c/5', sound: drumkit.snareSound })
      var hihatInstrument = new Instrument({ verticalPosition: 'g/5/x2', sound: drumkit.hihatSound })
      var kickInstrument = new Instrument({ verticalPosition: 'f/4', sound: drumkit.kickSound })

      function generateScore(sticking) {
        var newScore = [];
        for (var stick of sticking) {
          var note;
          switch (stick) {
            case 'R':
              note = new Note({ instrument: snareInstrument });
              break;
            case 'L':
              note = new Note({ instrument: snareInstrument });
              break;
            case 'K':
              note = new Note({ instrument: kickInstrument });
              break;
            default:
              break;
          }

          newScore.push(new NoteGroup([note], DURATION_SIXTEENTH))
        }

        return newScore;
      }

      var score = [
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: kickInstrument })], DURATION_SIXTEENTH),
        new NoteGroup([new Note({ instrument: hihatInstrument })], DURATION_SIXTEENTH),
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: kickInstrument })], DURATION_SIXTEENTH),
        new NoteGroup([new Note({ instrument: hihatInstrument })], DURATION_SIXTEENTH),
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: snareInstrument })], DURATION_EIGHTH),
        new NoteGroup([new Note({ instrument: hihatInstrument })], DURATION_EIGHTH),
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: kickInstrument })], DURATION_EIGHTH),
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: kickInstrument })], DURATION_EIGHTH),
        new NoteGroup([new Note({ instrument: hihatInstrument }), new Note({ instrument: snareInstrument })], DURATION_EIGHTH),
        new NoteGroup([new Note({ instrument: hihatInstrument })], DURATION_EIGHTH),
      ]
      generateNotation(score);

      document.getElementById('change_sticking').onclick = function() {
        var newSticking = document.getElementById('sticking').value;

        score = generateScore(newSticking);
        if (score.length < 16) {
          alert('Must have 16 notes!');
          return;
        }

        generateNotation(score);
      }

      document.getElementById('play').onclick = function() {
        var tempo = document.getElementById('tempo').value;
        RhythmSample.play(drumkit, score, tempo)
      }
    }

    function DrumKit(audioContext) {
      this.loader = new BufferLoader(
        audioContext,
        [
          '/acoustic-kit/kick.wav',
          '/acoustic-kit/snare.wav',
          '/acoustic-kit/hihat.wav',
        ]
        );
      this.loader.load();

      // functions since they are asynchronously loaded
      kickSound = function() { return this.loader.bufferList[0] };
      snareSound = function() { return this.loader.bufferList[1] };
      hihatSound = function() { return this.loader.bufferList[2] };
      this.kickSound = kickSound.bind(this);
      this.snareSound = snareSound.bind(this);
      this.hihatSound = hihatSound.bind(this);
    }

    // function DrumMachine(kit) {
    //   this.kit =
    // }

    var RhythmSample = {
    };

    function timeInTempo(duration, tempo) {
      switch (duration) {
        case DURATION_EIGHTH:
          return (60 / tempo) / 2;
          break;
        case DURATION_SIXTEENTH:
          return (60 / tempo) / 4;
          break;
        default:
          break;
      }
    }

    RhythmSample.play = function(drumkit, score, tempo) {
      function playSound(buffer, time) {
        var source = context.createBufferSource();
        source.buffer = buffer;
        source.connect(context.destination);
        if (!source.start) {
          source.start = source.noteOn;
        }
        source.start(time);
      }

      // We'll start playing the rhythm 100 milliseconds from "now"
      var startTime = context.currentTime + 0.100;

      var cumulativeTime = startTime;
      var plays = score.forEach(function(noteGroup) {
        var time = timeInTempo(noteGroup.duration, tempo);
        noteGroup.notes.forEach(function(note) {
          playSound(note.getSound(), cumulativeTime);
        });
        cumulativeTime += time;
      });
    };
  </script>
</body>
</html>