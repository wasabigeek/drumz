<!DOCTYPE html>
<html lang="en" style="height: 100%">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Over the Kit</title>
  <script type="text/javascript" src="js/bufferLoader.js"></script>
  <script type="text/javascript" src="https://unpkg.com/vexflow@3.0.9/releases/vexflow-min.js"></script>
</head>
<body style="display: flex; height: 100%; justify-content: center; align-items: center;">
  <div style="max-width: 500px; text-align: center;">
    <h1>Over the Kit</h1>
    <p>Quickly hear how different voicings of a sticking pattern sound at speed.</p>
    <p>(On a phone? Remember to turn off silent mode!)</p>
    <form id="stickingForm" style="margin: 2rem;">
      <label for="sticking">
        Sticking:
        <input id="sticking" value="RLKRLKRLKRLKRLRL" maxlength="16" minlength="16">
      </label>
      <button type="submit">Shuffle</button>
    </form>
    <div id="score" style="margin-bottom: 2rem;"></div>
    <form id="playerForm">
      <label for="tempo">
        Tempo:
        <input id="tempo" value="120" max="400" type="number">
      </label>
      <button type="submit">Play</button>
    </form>
  </div>
  <script type="text/javascript">
    window.onload = init;
    var context;
    var drumkit;
    var VF = Vex.Flow;
    var vf = new VF.Factory({
      renderer: {
        elementId: "score",
        backend: VF.Renderer.Backends.SVG,
        width: 450,
        height: 100,
      },
    });

    function Instrument(options) {
      this.verticalPosition = options.verticalPosition;
      this.sound = options.sound;
    }

    function Note(options) {
      this.instrument = options.instrument;
      this.volume = options.volume;

      this.verticalPosition = this.instrument.verticalPosition;
      // this has to be lazily retrieved now because the AudioContext needs to load
      this.getSound = this.instrument.sound;
    }
    DURATION_SIXTEENTH = 'sixteenth';
    DURATION_EIGHTH = 'eighth';
    DURATION_QUARTER = 'quarter';
    function NoteGroup(notes, duration) {
      this.notes = notes;
      this.duration = duration;

    }

    function toNotation(noteGroup) {
      var keys = noteGroup.notes.map(function(note) { return note.verticalPosition });

      var vfDuration;
      switch (noteGroup.duration) {
        case DURATION_EIGHTH:
          vfDuration = '8';
          break;
        case DURATION_SIXTEENTH:
          vfDuration = '16';
          break;
        default:
          break;
      }

      return {
        keys: keys,
        duration: vfDuration
      }
    }

    function createMeasure(setup) {
      var stave = vf.Stave().addClef('percussion');

      setup(vf);

      vf.Formatter()
        .joinVoices(vf.getVoices())
        .formatToStave(vf.getVoices(), stave);

      vf.draw();
    }

    function generateNotation(score) {
      var context = vf.getContext()
      context.clear();

      createMeasure(function(vf) {
        var voice0 = vf.Voice().addTickables(
          score.map(function(noteGroup) {
            return vf.StaveNote(toNotation(noteGroup));
          })
        );
        vf.Beam({ notes: voice0.getTickables() });
      });
    }

    // score (bars, play marker?, )
    // bar (notes by positions?)
    // note (duration, volume, instrument (voice + chart position))
    // rendering
    // player

    // flams/drags? rolls? ghost notes (maybe that's an instrument? since it has a voice attached to it)?

    function init() {
      // Fix up prefixing
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext();

      drumkit = new DrumKit(context);

      var snareInstrument = new Instrument({ verticalPosition: 'c/5', sound: drumkit.snareSound })
      var hihatInstrument = new Instrument({ verticalPosition: 'g/5/x2', sound: drumkit.hihatSound })
      var kickInstrument = new Instrument({ verticalPosition: 'f/4', sound: drumkit.kickSound })
      var tom1Instrument = new Instrument({ verticalPosition: 'e/5', sound: drumkit.tom1Sound })
      var tom2Instrument = new Instrument({ verticalPosition: 'd/5', sound: drumkit.tom2Sound })
      var tom3Instrument = new Instrument({ verticalPosition: 'a/4', sound: drumkit.tom3Sound })

      function generateScore(sticking) {
        var newScore = [];
        var handNotes = [
          new Note({ instrument: snareInstrument, volume: volume }),
          new Note({ instrument: hihatInstrument, volume: volume }),
          new Note({ instrument: tom1Instrument, volume: volume }),
          // new Note({ instrument: tom2Instrument, volume: volume }),
          new Note({ instrument: tom3Instrument, volume: volume }),
        ]

        for (var stick of sticking) {
          var note;
          // attempt to make it sound slightly more organic with volume variations
          var volume = 1 - Math.random() * 0.2;

          if (stick.toUpperCase() == 'K') {
            note = new Note({ instrument: kickInstrument, volume: volume });
          } else {
            note = handNotes[Math.round(Math.random() * (handNotes.length - 1))];
          }

          newScore.push(new NoteGroup([note], DURATION_SIXTEENTH))
        }

        return newScore;
      }

      var score = generateScore(document.getElementById('sticking').value);
      generateNotation(score);

      document.getElementById('stickingForm').onsubmit = function(e) {
        e.preventDefault();
        var newSticking = document.getElementById('sticking').value;

        score = generateScore(newSticking);
        if (score.length < 16) {
          alert('Must have 16 notes!');
          return;
        }

        generateNotation(score);
      }

      document.getElementById('playerForm').onsubmit = function(e) {
        e.preventDefault();
        var tempo = document.getElementById('tempo').value;
        RhythmSample.play(drumkit, score, tempo)
      }
    }

    function DrumKit(audioContext) {
      this.loader = new BufferLoader(
        audioContext,
        [
          'acoustic-kit/kick.wav',
          'acoustic-kit/snare.wav',
          'acoustic-kit/hihat.wav',
          'acoustic-kit/tom1.wav',
          'acoustic-kit/tom2.wav',
          'acoustic-kit/tom3.wav',
        ]
        );
      this.loader.load();

      // functions since they are asynchronously loaded
      kickSound = function() { return this.loader.bufferList[0] };
      snareSound = function() { return this.loader.bufferList[1] };
      hihatSound = function() { return this.loader.bufferList[2] };
      tom1Sound = function() { return this.loader.bufferList[3] };
      tom2Sound = function() { return this.loader.bufferList[4] };
      tom3Sound = function() { return this.loader.bufferList[5] };
      this.kickSound = kickSound.bind(this);
      this.snareSound = snareSound.bind(this);
      this.hihatSound = hihatSound.bind(this);
      this.tom1Sound = tom1Sound.bind(this);
      this.tom2Sound = tom2Sound.bind(this);
      this.tom3Sound = tom3Sound.bind(this);
    }

    var RhythmSample = {
    };

    function timeInTempo(duration, tempo) {
      switch (duration) {
        case DURATION_EIGHTH:
          return (60 / tempo) / 2;
          break;
        case DURATION_SIXTEENTH:
          return (60 / tempo) / 4;
          break;
        default:
          break;
      }
    }

    RhythmSample.play = function(drumkit, score, tempo) {
      function playSound(buffer, time, volume = 1) {

        var source = context.createBufferSource();
        source.buffer = buffer;

        var gainNode = context.createGain();
        gainNode.gain.setValueAtTime(volume, time);
        source.connect(gainNode);

        gainNode.connect(context.destination);

        if (!source.start) {
          source.start = source.noteOn;
        }
        source.start(time);
      }

      // We'll start playing the rhythm 100 milliseconds from "now"
      var startTime = context.currentTime + 0.100;

      var cumulativeTime = startTime;
      var plays = score.forEach(function(noteGroup) {
        var time = timeInTempo(noteGroup.duration, tempo);
        noteGroup.notes.forEach(function(note) {
          playSound(note.getSound(), cumulativeTime, note.volume);
        });
        cumulativeTime += time;
      });
    };
  </script>
</body>
</html>